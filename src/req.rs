use std::str::FromStr;
use serde::{Serialize, Deserialize};
use url::Url;
use reqwest::{Client, header, header::HeaderMap, Method, Response};
use anyhow::Result;
use reqwest::header::{HeaderName, HeaderValue};
use serde_json::json;
use crate::ExtraArgs;
use crate::config::ResponseProfile;
use std::fmt::Write;

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct RequestProfile {
    #[serde(with = "http_serde::method", default)]
    pub method: Method,
    pub url: Url,
    #[serde(skip_serializing_if = "empty_json_value", default)]
    pub params: Option<serde_json::Value>,
    #[serde(
    skip_serializing_if = "HeaderMap::is_empty",
    with = "http_serde::header_map",
    default
    )]
    pub headers: HeaderMap,
    #[serde(skip_serializing_if = "empty_json_value", default)]
    pub body: Option<serde_json::Value>,
}

#[derive(Debug)]
pub struct ResponseExt(Response);

fn empty_json_value(v: &Option<serde_json::Value>) -> bool {
    v.as_ref().map_or(true, |v| {
        v.is_null() || v.is_object() && v.as_object().unwrap().is_empty()
    })
}

impl RequestProfile {
    pub fn new(
        method: Method,
        url: Url,
        params: Option<serde_json::Value>,
        headers: HeaderMap,
        body: Option<serde_json::Value>,
    ) -> Self {
        Self {
            method,
            url,
            params,
            headers,
            body,
        }
    }
    pub async fn send(&self, args: &super::ExtraArgs) -> Result<ResponseExt> {
        let (header, query, body) = self.generate(args)?;
        let client = Client::new();
        let req = client
            .request(self.method.clone(), self.url.clone())
            .query(&query)
            .headers(header)
            .body(body)
            .build()?;
        let res = client.execute(req).await?;
        Ok(ResponseExt(res))
    }
    pub(crate) fn validate(&self) -> Result<()> {
        if let Some(params) = &self.params.as_ref() {
            if !params.is_object() {
                return Err(anyhow::anyhow!(
                    "Params must be an object but got: \n{}",
                    serde_yaml::to_string(params)?
                ));
            }
        }

        if let Some(body) = &self.body.as_ref() {
            if !body.is_object() {
                return Err(anyhow::anyhow!(
                    "Body must be an object but got: \n{}",
                    serde_yaml::to_string(body)?
                ));
            }
        }
        Ok(())
    }


    pub fn generate(
        &self,
        args: &ExtraArgs,
    ) -> Result<(HeaderMap, serde_json::Value, String)> {
        let mut headers: HeaderMap = self.headers.clone();
        let mut query = self.params.clone().unwrap_or_else(|| serde_json::json!({}));
        let mut body = self.body.clone().unwrap_or_else(|| serde_json::json!({}));
        for (k, v) in &args.headers {
            headers.insert(HeaderName::from_str(k)?, HeaderValue::from_str(v)?);
        }

        if !headers.contains_key(header::CONTENT_TYPE) {
            headers.insert(
                header::CONTENT_TYPE,
                HeaderValue::from_static("application/json"),
            );
        }

        for (k, v) in &args.query {
            query[k] = v.parse()?;
        }
        for (k, v) in &args.body {
            body[k] = v.parse()?;
        }

        let content_type = get_content_type(&headers);

        match content_type.as_deref() {
            Some("application/json") => {
                let body = serde_json::to_string(&body)?;
                Ok((headers, query, body))
            }
            Some("application/x-www-form-urlencoded" |
                 "multipart/form-data") => {
                let body = serde_urlencoded::to_string(&body)?;
                Ok((headers, query, body))
            }
            _ => Err(anyhow::anyhow!("Unsupported content type: {}", content_type.unwrap_or_default())),
        }
    }
}

impl ResponseExt {
    pub async fn get_text(self, profile: &ResponseProfile) -> Result<String> {
        let res = self.0;

        let mut output = get_header_text(&res, &profile.skip_headers)?;

        let content_type = get_content_type(res.headers());
        let text = res.text().await?;
        match content_type.as_deref() {
            Some("application/json") => {
                let text = filter_json(&text, &profile.skip_body)?;
                writeln!(&mut output, "{}", text)?;
            }
            _ => writeln!(&mut output, "{}", text)?,
        }
        Ok(output)
    }

    pub fn get_header_keys(&self) -> Vec<String> {
        let res = &self.0;
        let headers = res.headers();
        headers
            .iter()
            .map(|(k, _)| k.as_str().to_string())
            .collect()
    }


}

fn get_header_text(
    res: &Response,
    skip_headers: &[String],
) -> Result<String> {
    let mut output = String::new();
    writeln!(&mut output, "{:?} {}", res.version(), res.status())?;

    let headers = res.headers();
    for (k, v) in headers.iter() {
        if !skip_headers.iter().any(|sh| sh == k.as_str()) {
            output.push_str(&format!("{}: {:?}\r", k, v));
            writeln!(&mut output, "{}: {:?}", k, v)?;
        }
    }
    writeln!(&mut output, "\n")?;
    Ok(output)
}

fn filter_json(text: &str, skip: &[String]) -> Result<String> {
    let mut json: serde_json::Value = serde_json::from_str(text)?;

    if let serde_json::Value::Object(ref mut obj) = json {
        for k in skip {
            obj.remove(k);
        }
    }
    /*match json {
        serde_json::Value::Object(ref mut obj) => {
            for k in skip {
                obj.remove(k);
            }
        }
        _ => {}
    }*/

    for k in skip {
        json.as_object_mut().unwrap().remove(k);
        json[k] = json!(null);
    }
    Ok(serde_json::to_string_pretty(&json)?)
}

fn get_content_type(headers: &HeaderMap) -> Option<String> {
    headers
        .get(header::CONTENT_TYPE)
        .and_then(|v| v.to_str().unwrap().split(';').next().map(|v| v.to_string()))
        // .map(|v| v.to_str().unwrap().split(';').next())
        // .flatten()
        // .map(|v| v.to_string())
}

impl FromStr for RequestProfile {
    type Err = anyhow::Error;
    fn from_str(s: &str) -> Result<Self> {
        let mut url = Url::parse(s)?;
        let qs = url.query_pairs();
        let mut params = json!({});
        for (k, v) in qs {
            params[k] = v.parse()?;
        }
        url.set_query(None);
        Ok(RequestProfile::new(
            Method::GET,
            url,
            Some(params),
            HeaderMap::new(),
            None,
        ))
    }

}
